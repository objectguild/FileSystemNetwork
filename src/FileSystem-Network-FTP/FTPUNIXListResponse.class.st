"
A FTPUNIXListResponse parses FTP LIST Responses usually generated by an FTP Server running on *nix.

Based on Ruby code from https://github.com/stateless-systems/net-ftp-list.
"
Class {
	#name : #FTPUNIXListResponse,
	#superclass : #FTPListResponse,
	#instVars : [
		'owner',
		'group',
		'raw',
		'linkName',
		'posixPermissions'
	],
	#category : #'FileSystem-Network-FTP'
}

{ #category : #parsing }
FTPUNIXListResponse >> assignGroup: match [
	group := match subexpression: 20
]

{ #category : #parsing }
FTPUNIXListResponse >> assignLinks: match [
	| links |
	links := match subexpression: 17
]

{ #category : #parsing }
FTPUNIXListResponse >> assignModificationTime: match [
	| timeOrYear monthAndDay mtimeString |
	monthAndDay := match subexpression: 24.
	timeOrYear := match subexpression: 27.
	mtimeString := (timeOrYear matchesRegex: '^[0-9]{1,2}\:[0-9]{2}$')
		ifTrue: [ 
			(DateAndTime fromString: ('<1s> <2p>' expandMacrosWith: monthAndDay with: self dateAndTimeNow year))
				> self dateAndTimeNow
				ifTrue: [ '<1s> <2p> <3s>' expandMacrosWith: monthAndDay with: self dateAndTimeNow year - 1 with: timeOrYear ]
				ifFalse: [ '<1s> <2p> <3s>' expandMacrosWith: monthAndDay with: self dateAndTimeNow year with: timeOrYear ] ]
		ifFalse: [ 
			(timeOrYear matchesRegex: '^[0-9]{4}$')
				ifTrue: [ '<1s> <2s>' expandMacrosWith: monthAndDay with: timeOrYear ]
				ifFalse: [ self error: 'Coulnd''t parse' ] ].	"Unix mtimes specify a 4 digit year unless the data is within the past 180  days or so. Future dates always specify a 4 digit year. If the parsed date, with today's year, could be in the future, then the date must be for the previous year"
	modificationTime := DateAndTime fromString: mtimeString
]

{ #category : #parsing }
FTPUNIXListResponse >> assignName: match [
	| filename |
	filename := match subexpression: 29.
	(match subexpression: 30) ifNotNil: [ :value | filename := filename , value ].	"filenames with spaces will end up in the last match"
	((match := '(\S+)(\s->\s(\S+))?' asRegex) matches: filename)
		ifTrue: [ 
			name := match subexpression: 2.
			linkName := match subexpression: 4 ]
		ifFalse: [ 
			name := filename.
			linkName := nil ]
]

{ #category : #parsing }
FTPUNIXListResponse >> assignOwner: match [
	owner := match subexpression: 18
]

{ #category : #parsing }
FTPUNIXListResponse >> assignPosixPermission: match [
	posixPermissions := 0.
	(match subexpression: 3)
		do: [ :each | 
			posixPermissions := posixPermissions * 2.
			each = $-
				ifFalse: [ posixPermissions := posixPermissions + 1 ] ] 
]

{ #category : #parsing }
FTPUNIXListResponse >> assignSize: match [
	size := (match subexpression: 23) asInteger
]

{ #category : #parsing }
FTPUNIXListResponse >> assignType: match [
	| expression |
	expression := match subexpression: 2.
	(expression matchesRegexIgnoringCase: '[-f]')
		ifTrue: [ ^ type := #file ].
	(expression matchesRegexIgnoringCase: 'd')
		ifTrue: [ ^ type := #directory ].
	(expression matchesRegexIgnoringCase: 'l')
		ifTrue: [ ^ type := #symlink ].
	(expression matchesRegexIgnoringCase: '[psbc]')
		ifTrue: [ ^ type := #device ]
]

{ #category : #accessing }
FTPUNIXListResponse >> group [
	^ group
]

{ #category : #accessing }
FTPUNIXListResponse >> linkName [
	^ linkName
]

{ #category : #parsing }
FTPUNIXListResponse >> matchRumpus: match [
	"Don't match on rumpus (which looks very similar to unix)"

	"return false if match[17].nil? and ((match[15].nil? and match[16].to_s == 'folder') or match[15].to_s == '0')"

	^ ((match subexpression: 19) isNil
		and: [ (match subexpression: 17) isNil and: [ (match subexpression: 18) = 'folder' ] ])
		or: [ (match subexpression: 17) = '0' ]
]

{ #category : #accessing }
FTPUNIXListResponse >> owner [
	^ owner
]

{ #category : #parsing }
FTPUNIXListResponse >> parse: aString [
	| match |
	match := ('([pbcdlfmpSs-])' , '(((r|-)(w|-)([xsStTL-]))((r|-)(w|-)([xsStTL-]))((r|-)(w|-)([xsStTL-])))\+?\s+'
		, '((\d+)\s+)?' , '(\S+)\s+' , '((\S+(\s\S+)*)\s+)?' , '(\d+,\s+)?' , '(\d+)\s+'
		, '((\d+[-/]\d+[-/]\d+)|(\S+\s+\S+))\s+' , '(\d+(\:\d+)?)\s+' , '(\S*)(\s*.*)') asRegex.
	(match matches: aString)
		ifFalse: [ ^ nil ].
	self assignType: match.
	type ifNil: [ ^ nil ]. 
	(self matchRumpus: match)
		ifTrue: [ ^ nil ].
	self assignPosixPermission: match.
	self assignLinks: match.
	self assignOwner: match.
	self assignGroup: match.
	self assignSize: match.
	self assignModificationTime: match.
	self assignName: match.
	raw := aString
]

{ #category : #accessing }
FTPUNIXListResponse >> posixPermissions [
	^ posixPermissions
]

{ #category : #accessing }
FTPUNIXListResponse >> raw [
	^ raw
]

{ #category : #accessing }
FTPUNIXListResponse >> raw: anObject [
	raw := anObject
]
